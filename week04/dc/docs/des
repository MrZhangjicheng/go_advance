由于平时工作中使用的服务为单体服务，没有采用微服务架构，所以毛剑老师给的示例不能完全照搬
不同之处
    1.单体服务中的入参和出参为json格式,并且出参由前端传入，出参直接给前端使用 (由于前端只能以httq请求后端服务，所以这个一块在微服务中应该类似与apigateway)
解决:
    1.入参定义，/internal/service ,出参定义，/internal/serializer, 由于之前使用贫血模式,以model定义的对象进行全局流转,现在以DO(internal/biz)做流转
    DO层包含Repo接口,同时在/internal/data/po定义数据模型,该数据模型使用gorm框架，定义简单的crud,在/internal/data层中实现DO层的Repo接口，并对PO层的进行封装
    和组合,在Repo这一层需要将数据库的连接进行注入/internal/data 负责对应数据库连接创建
    数据流转过程：
        前端入参 + Repo  => DTO 
        DTO 进行构建 Domain, Repo通过使用 DOmain去操作基础数据
        出参 也是通过 Domain 构建
    所以在整个数据流转过程中 Domain 是基础，而真正的PO不在被全局依赖
问题：
    由于时间原因，没有用wire去进行依赖注入,都是采用手写方式，同时也不确定这个方式是否合理，(微服务中的列子,感觉是各种依赖最终注册成一个框架的运行实例(eg:kratos.app),但在gin中如何将
    依赖注册成一个gin.Engine),目前对于数据库连接采用单例模式,在newRepo时，传入该实例


总结:
    由于时间较短,还是有很多知识理解不够清晰,但是工程化本身应该没有问题，只是需要我们根据实际的服务形态去调整,或许做不到完美,但是可以尽量忘标准上靠
        
      